 <script>
    // å’Œ write ä¿æŒä¸€è‡´çš„ API åœ°å€
    const API_BASE_URL = 'https://api.anchorx.ca/api/works';

    // ç”Ÿæˆå¸¦ Authorization çš„è¯·æ±‚å¤´
    function authHeaders(json) {
      const h = { 'Authorization': 'Bearer ' + (localStorage.getItem('token') || '') };
      if (json) h['Content-Type'] = 'application/json';
      return h;
    }

    // Delta -> çº¯æ–‡æœ¬ï¼ˆç”¨äºè‡ªåŠ¨æŒ‰è¡Œæ‹†ï¼‰
    function deltaToPlainText(delta) {
      if (!delta || typeof delta !== 'object' || !Array.isArray(delta.ops)) return '';
      let text = '';
      delta.ops.forEach(op => {
        if (typeof op.insert === 'string') text += op.insert;
      });
      return text;
    }

    document.addEventListener('DOMContentLoaded', () => {
      const listPage = document.getElementById('effect-list-page');
      const editorPage = document.getElementById('effect-editor-page');
      const workListEl = document.getElementById('effect-work-list');
      const workCountEl = document.getElementById('effect-work-count');

      const backBtn = document.getElementById('effect-back-btn');
      const editorTitleEl = document.getElementById('effect-editor-title');

      const lineListEl = document.getElementById('effect-line-list');
      const selectedLineLabel = document.getElementById('effect-selected-line-label');
      const debugJsonEl = document.getElementById('effect-debug-json');

      const previewBtn = document.getElementById('effect-preview-btn');
      const saveDraftBtn = document.getElementById('effect-save-draft-btn');
      const publishBtn = document.getElementById('effect-publish-btn');
      const removeEffectBtn = document.getElementById('effect-remove-btn');

      let currentWorkId = null;
      let currentLines = [];         // æ‰€æœ‰è¡Œæ–‡æœ¬
      let selectedLineIndex = null;  // å½“å‰é€‰ä¸­è¡Œ
      let effectsDraft = [];         // [{ lineIndex, effectType }]
      let isPreviewing = false;

      /* ---------- ä½œå“ç›¸å…³ ---------- */

      async function fetchMyWorks() {
        try {
          const res = await fetch(API_BASE_URL, { headers: authHeaders(false) });
          if (res.status === 401) {
            alert('ç™»å½•å·²å¤±æ•ˆï¼Œè¯·é‡æ–°ç™»å½•');
            window.location.href = 'https://zhidianworld.com/login/';
            return [];
          }
          if (!res.ok) {
            const j = await res.json().catch(() => ({}));
            alert('è·å–ä½œå“å¤±è´¥ï¼š' + (j.message || res.status));
            return [];
          }
          return await res.json();
        } catch (e) {
          console.error(e);
          alert('ç½‘ç»œé”™è¯¯ï¼Œæ— æ³•åŠ è½½ä½œå“');
          return [];
        }
      }

      async function loadWorkList() {
        workListEl.innerHTML = '<p style="text-align:center;color:#999;margin-top:50px;">æ­£åœ¨åŠ è½½ä½œå“...</p>';
        const works = await fetchMyWorks();
        if (!works || works.length === 0) {
          workListEl.innerHTML = '<p style="text-align:center;color:#999;margin-top:50px;">æš‚æ— ä½œå“ã€‚</p>';
          workCountEl.textContent = '0';
          return;
        }

        workListEl.innerHTML = '';
        works.forEach(w => {
          const div = document.createElement('div');
          div.className = 'work-item-wrapper';
          div.dataset.id = w._id;
          div.innerHTML = `
            <div class="work-item">
              <div class="work-info">
                <div class="work-date">${new Date(w.updatedAt).toLocaleString()}</div>
                <div class="work-details">
                  <span class="work-title">${w.title}</span>
                </div>
              </div>
              <button class="create-button" data-action="edit-effects">ç¼–è¾‘ç‰¹æ•ˆ</button>
            </div>
          `;
          workListEl.appendChild(div);
        });
        workCountEl.textContent = String(works.length);
      }

      workListEl.addEventListener('click', async e => {
        const btn = e.target.closest('[data-action="edit-effects"]');
        if (!btn) return;
        const wrapper = btn.closest('.work-item-wrapper');
        if (!wrapper) return;
        const id = wrapper.dataset.id;
        await enterEffectEditor(id);
      });

      /* ---------- è¿›å…¥ç‰¹æ•ˆç¼–è¾‘å™¨ ---------- */

      async function fetchWorkById(id) {
        try {
          const res = await fetch(API_BASE_URL + '/' + id, { headers: authHeaders(false) });
          if (!res.ok) {
            throw new Error('åŠ è½½å¤±è´¥');
          }
          return await res.json();
        } catch (e) {
          console.error(e);
          alert('åŠ è½½ä½œå“å¤±è´¥');
          return null;
        }
      }

      async function enterEffectEditor(workId) {
        const work = await fetchWorkById(workId);
        if (!work) return;

        currentWorkId = workId;
        editorTitleEl.textContent = work.title || '';
        // è¯»å–å·²æœ‰è‰ç¨¿/å·²å‘å¸ƒç‰¹æ•ˆï¼ˆå¦‚æœä½ åœ¨åç«¯åŠ äº†å­—æ®µï¼‰
        // ä¼˜å…ˆåŠ è½½ effectsDraftï¼›è‹¥è‰ç¨¿ä¸ºç©ºåˆ™åŠ è½½å·²å‘å¸ƒ
if (Array.isArray(work.effectsDraft) && work.effectsDraft.length > 0) {
    effectsDraft = work.effectsDraft.map(e => ({
        lineIndex: e.lineIndex,
        effectType: e.effectType
    }));
} else {
    effectsDraft = (work.effectsPublished || []).map(e => ({
        lineIndex: e.lineIndex,
        effectType: e.effectType
    }));
}


        // åˆå¹¶æ‰€æœ‰é¡µé¢æ–‡æœ¬
        const pages = Array.isArray(work.content) ? work.content : [];
        let fullText = '';
        pages.forEach((p, idx) => {
          const t = deltaToPlainText(p.content || {});
          if (idx > 0) fullText += '\n';       // é¡µé¢ä¹‹é—´ä¹Ÿæ¢ä¸€è¡Œ
          fullText += t;
        });

        currentLines = fullText.split(/\r?\n/);

        renderLineList();
        updateDebugJson();

        listPage.classList.add('hidden');
        editorPage.classList.remove('hidden');
      }

      backBtn.addEventListener('click', () => {
        editorPage.classList.add('hidden');
        listPage.classList.remove('hidden');
        currentWorkId = null;
        currentLines = [];
        effectsDraft = [];
        selectedLineIndex = null;
        isPreviewing = false;
        lineListEl.innerHTML = '';
        selectedLineLabel.textContent = 'æ— ';
        previewBtn.textContent = 'é¢„è§ˆç‰¹æ•ˆ';
      });

      /* ---------- è¡Œåˆ—è¡¨ / é€‰ä¸­è¡Œ / è®¾ç½®ç‰¹æ•ˆ ---------- */

      function renderLineList() {
        lineListEl.innerHTML = '';
        currentLines.forEach((lineText, idx) => {
          const li = document.createElement('li');
          li.className = 'effect-line-item';
          li.dataset.index = idx;

          const tag = effectsDraft.find(e => e.lineIndex === idx);

          li.innerHTML = `
            <div class="effect-line-num">${idx + 1}</div>
            <div class="effect-line-text">${lineText === '' ? '&nbsp;' : escapeHtml(lineText)}</div>
            <div class="effect-line-tags">
              ${tag ? `<span class="effect-tag">${effectTypeLabel(tag.effectType)}</span>` : ''}
            </div>
          `;

          // å¦‚æœå½“å‰æ˜¯é€‰ä¸­è¡Œ
          if (idx === selectedLineIndex) {
            li.classList.add('selected');
          }

          lineListEl.appendChild(li);
        });

        if (isPreviewing) {
          applyPreviewClasses();
        }

        lineListEl.scrollTop = 0;
      }

      function escapeHtml(str) {
        return str.replace(/[&<>"']/g, s => ({
          '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#39;'
        }[s]));
      }

      function effectTypeLabel(type) {
        switch (type) {
          case 'shake': return 'éœ‡åŠ¨';
          case 'flash': return 'é—ªçƒ';
          case 'fade': return 'æ·¡å…¥';
          case 'highlight': return 'é«˜äº®';
          default: return type;
        }
      }

      lineListEl.addEventListener('click', e => {
        const item = e.target.closest('.effect-line-item');
        if (!item) return;
        const idx = Number(item.dataset.index);
        selectedLineIndex = idx;

        // æ›´æ–°é€‰ä¸­æ ·å¼
        document.querySelectorAll('.effect-line-item').forEach(li => li.classList.remove('selected'));
        item.classList.add('selected');

        selectedLineLabel.textContent = 'ç¬¬ ' + (idx + 1) + ' è¡Œ';
      });

      // è®¾ç½®/æ¸…é™¤æŸä¸€è¡Œç‰¹æ•ˆ
      function setEffectForLine(lineIndex, effectType) {
        const existingIndex = effectsDraft.findIndex(e => e.lineIndex === lineIndex);
        if (!effectType) {
          if (existingIndex >= 0) effectsDraft.splice(existingIndex, 1);
        } else {
          if (existingIndex >= 0) {
            effectsDraft[existingIndex].effectType = effectType;
          } else {
            effectsDraft.push({ lineIndex, effectType });
          }
        }
        updateDebugJson();
        renderLineList();
      }

      document.querySelectorAll('.effect-btn').forEach(btn => {
        btn.addEventListener('click', () => {
          if (selectedLineIndex == null) {
            alert('è¯·å…ˆç‚¹å‡»å·¦ä¾§æŸä¸€è¡Œå†æ’å…¥ç‰¹æ•ˆ');
            return;
          }
          const effectType = btn.dataset.effect;
          setEffectForLine(selectedLineIndex, effectType);
        });
      });

      removeEffectBtn.addEventListener('click', () => {
        if (selectedLineIndex == null) {
          alert('è¯·å…ˆé€‰æ‹©ä¸€è¡Œ');
          return;
        }
        setEffectForLine(selectedLineIndex, null);
      });

      /* ---------- é¢„è§ˆç‰¹æ•ˆ ---------- */

      function applyPreviewClasses() {
        document.querySelectorAll('.effect-line-text').forEach((el, idx) => {
          el.classList.remove('effect-shake', 'effect-flash', 'effect-fade', 'effect-highlight');
          const tag = effectsDraft.find(e => e.lineIndex === idx);
          if (!tag) return;
          switch (tag.effectType) {
            case 'shake': el.classList.add('effect-shake'); break;
            case 'flash': el.classList.add('effect-flash'); break;
            case 'fade': el.classList.add('effect-fade'); break;
            case 'highlight': el.classList.add('effect-highlight'); break;
          }
        });
      }

      function clearPreviewClasses() {
        document.querySelectorAll('.effect-line-text').forEach(el => {
          el.classList.remove('effect-shake', 'effect-flash', 'effect-fade', 'effect-highlight');
        });
      }

      previewBtn.addEventListener('click', () => {
        isPreviewing = !isPreviewing;
        if (isPreviewing) {
          applyPreviewClasses();
          previewBtn.textContent = 'å…³é—­é¢„è§ˆ';
        } else {
          clearPreviewClasses();
          previewBtn.textContent = 'é¢„è§ˆç‰¹æ•ˆ';
        }
      });

      /* ---------- ä¿å­˜è‰ç¨¿ / å‘å¸ƒç‰¹æ•ˆ ---------- */
      function updateDebugJson() {
        debugJsonEl.textContent = JSON.stringify(effectsDraft, null, 2);
      }

      async function saveEffectsDraft(isPublish) {
        if (!currentWorkId) {
          alert('æœªé€‰æ‹©ä½œå“');
          return;
        }
        const fieldName = isPublish ? 'effectsPublished' : 'effectsDraft';
        try {
          const res = await fetch(API_BASE_URL + '/' + currentWorkId, {
            method: 'PATCH',
            headers: authHeaders(true),
            body: JSON.stringify({ [fieldName]: effectsDraft })
          });
          const j = await res.json().catch(() => ({}));
          if (!res.ok) {
            alert((isPublish ? 'å‘å¸ƒ' : 'ä¿å­˜è‰ç¨¿') + 'å¤±è´¥ï¼š' + (j.message || res.status));
            return;
          }
          alert(isPublish ? 'ç‰¹æ•ˆå·²å‘å¸ƒï¼ï¼ˆä½†æ˜¯å¤§æ¦‚ç‡é˜…è¯»ç«¯è¿˜æ˜¯æ˜¾ç°ä¸å‡ºæ¥çš„ï¼Œæ­£åœ¨åŠªåŠ›ä¿®bugä¸­ï¼‰' : 'è‰ç¨¿å·²ä¿å­˜ï¼');
// ğŸ”¥ è‡ªåŠ¨åˆ·æ–°æ•°æ®ï¼Œå›å¡« UI
enterEffectEditor(currentWorkId);
        } catch (e) {
          console.error(e);
          alert((isPublish ? 'å‘å¸ƒ' : 'ä¿å­˜') + 'å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œ');
        }
      }

      saveDraftBtn.addEventListener('click', () => saveEffectsDraft(false));
      publishBtn.addEventListener('click', () => {
        if (!confirm('ç¡®å®šå‘å¸ƒå½“å‰ç‰¹æ•ˆé…ç½®ï¼Ÿ')) return;
        saveEffectsDraft(true);
      });

      /* ---------- åˆå§‹åŒ– ---------- */
      loadWorkList();
    });
  </script>